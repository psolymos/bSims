[{"path":"/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, interest fostering open welcoming community, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality. Examples unacceptable behavior participants include: use sexualized language imagery Personal attacks Trolling insulting/derogatory comments Public private harassment Publishing ’s private information, physical electronic addresses, without explicit permission unethical unprofessional conduct Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful. adopting Code Conduct, project maintainers commit fairly consistently applying principles every aspect managing project. Project maintainers follow enforce Code Conduct may permanently removed project team. Code Conduct applies within project spaces public spaces individual representing project community. Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project maintainer solymos@ualberta.ca. complaints reviewed investigated result response deemed necessary appropriate circumstances. Maintainers obligated maintain confidentiality regard reporter incident. Code Conduct adapted Contributor Covenant, version 1.3.0, available http://contributor-covenant.org/version/1/3/0/","code":""},{"path":"/articles/bsims01-intro.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to the bSims package","text":"bSims R package highly scientific utterly addictive bird point count simulator. Highly scientific, implements spatially explicit mechanistic simulation based statistical models widely used bird point count analysis (.e. removal models, distance sampling), utterly addictive implementation designed allow rapid interactive exploration (via shiny apps) efficient simulation (supporting various parallel backends), thus elevating user experience. goals package : allow easy testing statistical assumptions explore effects violating assumptions, aid survey design comparing different options, importantly, fun via intuitive interactive user interface. simulation interface designed following principles mind: isolation: spatial scale small (local point count scale) can treat individual landscapes less homogeneous units (see certain stratified designs edge effects can incorporated) independent space time; realism: implementation biological mechanisms observation processes realistic, defaults chosen reflect common practice assumptions; efficiency: implementation computationally efficient utilizing parallel computing backends available; extensibility: package functionality well documented easily extensible. documents outlines major functionality package. First describe motivation simulation details layers. outline interactive workflow design simulation studies describe run efficient simulation experiments. Finally present current limitations framework extend existing functionality package incorporate biological realism simulations.","code":""},{"path":"/articles/bsims01-intro.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Introduction to the bSims package","text":"Point-count surveys one widely used survey techniques birds. method involves observer standing location recording birds detected set amount time within fixed unlimited distance away observer. data collected way often used trend monitoring, assessing landscape climate change effects bird populations, setting population goals conservation. Point counts provide index true abundance survey location due imperfect detection. plethora design model based solutions exist minimize impacts account biases due imperfect detection. Contrary importance point counts among field methods landbirds, generally applicable simulation tool help better understand possible biases help aiding survey design. Currently available simulation tools either concerned movement trajectories bird flocks mitigate mortality near airports wind farms specific statistical models. Statistical techniques expected provide unbiased estimates data generation process follows assumptions model. However, testing model assumptions realistic rarely evaluated rigor. apparent lack general purpose simulation tools point counts can probably attributed fact reality complex situations immediately straightforward best tackle complexity. illustrate claim, ecological modellers approach bird density. Counts (Y) described marginal distribution, e.g. Y ~ Poisson(DApq) D density (abundance per unit area), survey area, p probability individuals available sampling, whereas q detection probability given availability. model also viewed mixture distribution: N ~ Poisson(DA), Y ~ Binomial(N, pq). gives straightforward algorithm generating counts known D, , p, q parameters, can turn used test statistical performance (unbiasedness, consistency) N-mixture, time-removal, distance sampling models among others. Reality, however, often complicated. Take example roadside counts, served main motivations developing simulation approaches presented . Bird surveys along roads widespread due logistical, safety, cost considerations. case, even though differences roadside -road counts well documented.differences indicate roadside bias due , e.g., density, behaviour detectability different depending distance road. Understanding nature sources roadside count bias might lend simple simulations based marginal distributions. Understanding roadside counts requires spatially explicit mechanistic simulation approach. bSims R package presents spatially explicit mechanistic simulation framework. design informed statistical models widely used analyses bird point count data (.e. removal models, distance sampling). implementation allows real time interactive exploration via Shiny apps followed efficient simulations supporting various parallel backends. goals package (1) allow easy testing statistical assumptions explore effects violating assumptions; (2) aid survey design comparing different options; (3) fun . paper, demonstrate main functionality package, outline interactive workflow design efficiently run simulation experiments, finally present future directions extend existing functionality package incorporating biological realism simulations.","code":""},{"path":"/articles/bsims01-intro.html","id":"design-and-implementation","dir":"Articles","previous_headings":"","what":"Design and implementation","title":"Introduction to the bSims package","text":"simulation interface designed following principles mind: Isolation: spatial scale small (local point count scale) can treat individual landscapes less homogeneous units (see certain stratified designs edge effects can incorporated) independent space time; Realism: implementation biological mechanisms observation processes realistic, defaults chosen reflect common practice assumptions; Efficiency: implementation computationally efficient utilizing parallel computing backends available; Extensibility: package functionality well documented easily extensible. Going back Poisson–Binomial example, N result factors influencing bird abundance, geographic location, season, habitat suitability, number conspecifics, competitors, predators. Y, however, largely depend birds behave depending time day, observer might detect miss different individuals, count individual twice, etc. series conditional filtering events lends represented layers. simulation layers conditionally independent . design can facilitate comparison certain settings keeping underlying layers realizations identical. can help pinpointing effects without extra variability introduced underlying layers. bSims package implements following main ‘verb’ functions simulating conditionally independent layers: Initialize (bsims_init): landscape defined extent possible habitat stratification; Populate (bsims_populate): population finite number individuals within extent landscape; Animate (bsims_animate): individual behaviours described movement vocalization events, .e. frequency sending various types signals; Detect (bsims_detect): physical side observation process, .e. transmitting receiving signal; Transcribe (bsims_transcribe): “human” aspect observation process, .e. perception received signal. bsims_ part function helps finding functions via autocomplete functionality developer environment, RStudio VSCode. next sections review main options available simulation layers (see Appendix worked examples reproducible code).","code":""},{"path":"/articles/bsims01-intro.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Introduction to the bSims package","text":"package equipped possible ways estimate model parameters. rudimentary removal modeling distance sampling functionality implemented interactive visualization testing purposes. Estimating parameters complex situations (.e. finite mixture removal models, via Hazard rate distance functions) estimating abundance via multiple-visit N-mixture models etc. outside scope package responsibility user make sure work expected. intentional limitation package lack reverse interactions layers. example presence observer influence behavior birds close observer. features can implemented methods extending current functionality. Another limitation implementation considers single species. Observers rarely collect data single species rather count multiple species part survey. commonness species, observer ability, etc. can influence observation process whole community considered. scenarios also considered present. Although landscape can reused multiple species, building simulation way. package considers simulations independent space time. larger landscapes need simulated, might several options: (1) simulate larger extent put multiple independent observers landscape; (2) simulate independent landscapes isolation. latter approach can also address spatial temporal heterogeneity density, behaviour, etc. E.g. singing rate changing function time day, one can define vocal_rate values function time, simulate independent animation layers. density varies space, one can simulate independent population layers. limitations can addressed additional methods modules extending capabilities package, added functionality core layer functions future releases.","code":""},{"path":"/articles/bsims02-layers.html","id":"landscape","dir":"Articles","previous_headings":"","what":"Landscape","title":"Simulation layers in bSims","text":"bsims_ini function sets geometry local landscape. extent landscape determines edge lengths square shaped area. argument values passed, function assumes homogeneous habitat (H) 10 units x 10 units landscape, 1 unit 100 meters. units way allows easier conversion ha area unit often used North American bird literature. result, landscape area 1 km\\(^2\\). road argument defines half-width road placed vertical position. edge argument defines width edge stratum sides road. Habitat (H), edge (E), road (R) defines 3 strata refer initials (H stratification, 3 strata present). origin Cartesian coordinate system inside landscape centered middle square. offset argument allows road edge strata shifted left (negative values) right (positive values) horizontal axis. makes possible create landscapes two strata. bsims_init function returns landscape object (class ‘bsims_landscape’).","code":"(l1 <- bsims_init(extent = 10, road = 0, edge = 0, offset = 0)) #> bSims landscape #>   1 km x 1 km #>   stratification: H (l2 <- bsims_init(extent = 10, road = 1, edge = 0, offset = 0)) #> bSims landscape #>   1 km x 1 km #>   stratification: HR (l3 <- bsims_init(extent = 10, road = 0.5, edge = 1, offset = 2)) #> bSims landscape #>   1 km x 1 km #>   stratification: HER (l4 <- bsims_init(extent = 10, road = 0, edge = 5, offset = 5)) #> bSims landscape #>   1 km x 1 km #>   stratification: HE  op <- par(mfrow = c(2, 2)) plot(l1, main = \"Habitat\") points(0, 0, pch=3) plot(l2, main = \"Habitat & road\") lines(c(0, 0), c(-5, 5), lty=2) plot(l3, main = \"Habitat, edge, road + offset\") arrows(0, 0, 2, 0, 0.1, 20) lines(c(2, 2), c(-5, 5), lty=2) points(0, 0, pch=3) plot(l4, main = \"2 habitats\") arrows(0, 0, 5, 0, 0.1, 20) lines(c(5, 5), c(-5, 5), lty=2) points(0, 0, pch=3) par(op)"},{"path":"/articles/bsims02-layers.html","id":"population","dir":"Articles","previous_headings":"","what":"Population","title":"Simulation layers in bSims","text":"bsims_populate function populates landscape created bsims_init function, first argument pass bsims_populate. function returns population object (class ‘bsims_population’). important argument controls many individuals inhabit landscape density defines expected value individuals per unit area (1 ha). default, density = 1 (\\(D=1\\)) 100 ha landscape (\\(=100\\)) translates 100 individuals average (\\(E[N]=\\lambda=AD\\)). actual number individuals landscape might deviate expectation, \\(N\\) random variable (\\(N \\sim f(\\lambda)\\)). abund_fun argument controls relationship expected (\\(\\lambda\\)) realized abundance (\\(N\\)). default Poisson distribution: Changing abund_fun can useful make abundance constant allow overdispersion, e.g.: determine many individuals populate landscape, control spatial arrangement nest location individual. default homogeneous Poisson point process (complete spatial randomness). Deviations can controlled xy_fun. function takes distance argument returns numeric value 0 1. function function(d) reurn(1) equivalent Poisson process, meaning every new random location accepted probability 1 irrespective distance new location previously generated point locations landscape. function varies distance, leads non-homogeneous point process via accept-reject algorithm. arguments (margin, maxit, fail) passed underlying accepreject function remove edge effects handle high rejection rates. next example, fix abundance constant (.e. random variable, \\(N=\\lambda\\)) different spatial point processes:  get_nests function extracts nest locations. get_abundance get_density gives total abundance (\\(N\\)) density (\\(D=N/\\), \\(\\) extent^2) landscape, respectively. landscape stratified, effect density unless specify different values density argument vector length 3 referring strata:","code":"bsims_populate(l1) #> bSims population #>   1 km x 1 km #>   stratification: H #>   total abundance: 116 summary(rpois(100, 100)) # Poisson variation #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   72.00   94.75  100.50  101.01  107.25  130.00 summary(MASS::rnegbin(100, 100, 0.8)) # NegBin variation #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>     0.0    15.0    64.0   105.8   158.2   567.0 negbin <- function(lambda, ...) MASS::rnegbin(1, lambda, ...) bsims_populate(l1, abund_fun = negbin, theta = 0.8) #> bSims population #>   1 km x 1 km #>   stratification: H #>   total abundance: 58 ## constant abundance bsims_populate(l1, abund_fun = function(lambda, ...) lambda) #> bSims population #>   1 km x 1 km #>   stratification: H #>   total abundance: 100 D <- 0.5 f_abund <- function(lambda, ...) lambda  ## systematic f_syst <- function(d)   (1-exp(-d^2/1^2) + dlnorm(d, 2)/dlnorm(exp(2-1),2)) / 2 ## clustered f_clust <- function(d)   exp(-d^2/1^2) + 0.5*(1-exp(-d^2/4^2))  p1 <- bsims_populate(l1, density = D, abund_fun = f_abund) p2 <- bsims_populate(l1, density = D, abund_fun = f_abund, xy_fun = f_syst) p3 <- bsims_populate(l1, density = D, abund_fun = f_abund, xy_fun = f_clust)  distance <- seq(0,10,0.01) op <- par(mfrow = c(3, 2)) plot(distance, rep(1, length(distance)), type=\"l\", ylim = c(0, 1),    main = \"random\", ylab=expression(f(d)), col=2) plot(p1)  plot(distance, f_syst(distance), type=\"l\", ylim = c(0, 1),    main = \"systematic\", ylab=expression(f(d)), col=2) plot(p2)  plot(distance, f_clust(distance), type=\"l\", ylim = c(0, 1),    main = \"clustered\", ylab=expression(f(d)), col=2) plot(p3) par(op) D <- c(H = 2, E = 0.5, R = 0)  op <- par(mfrow = c(2, 2)) plot(bsims_populate(l1, density = D), main = \"Habitat\") plot(bsims_populate(l2, density = D), main = \"Habitat & road\") plot(bsims_populate(l3, density = D), main = \"Habitat, edge, road + offset\") plot(bsims_populate(l4, density = D), main = \"2 habitats\") par(op)"},{"path":"/articles/bsims02-layers.html","id":"behavior","dir":"Articles","previous_headings":"","what":"Behavior","title":"Simulation layers in bSims","text":"bsims_animate function animates population created bsims_populate function. bsims_animate returns events object (class ‘bsims_events’). important arguments governing duration simulation minutes, vocalization (vocal_rate), movement (move_rate) rates average number events per minute. can describe behavioral events using survival modeling terminology. Event time (\\(T\\)) continuous random variable. simplest case, probability density function Exponential distribution: \\(f(t)=\\phi e^{-t\\phi}\\). corresponding cumulative distribution function : \\(F(t)=\\int_{0}^{t} f(t)dt=1-e^{-t\\phi}=p_t\\), giving probability event occurred duration \\(t\\). parameter \\(\\phi\\) rate Exponential distribution mean \\(1/\\phi\\) variance \\(1/\\phi^2\\). survival models, complement \\(F(t)\\) called survival function (\\(S(t)=1-F(t)\\), \\(S(0)=1\\)), gives probability event occurred duration \\(t\\). hazard function (\\(\\lambda(t)=f(t)/S(t)\\)) defines instantaneous rate occurrence event (risk, density events \\(t\\) divided probability surviving). cumulative hazard (cumulative risk) sum risks duration 0 \\(t\\) (\\(\\Lambda(t)=\\int_{0}^{t} \\lambda(t)dt\\)). simplest survival distribution assumes constant risk time (\\(\\lambda(t)=\\phi\\)), corresponds Exponential distribution. Exponential distribution also happens describe lengths inter-event times homogeneous Poisson process (events independent, ‘memory-less’ process). bsims_animate uses independent Exponential distributions rates vocal_rate move_rate simulate vocalization movement events, respectively. get_events function extracts events data frame columns describing location (x, y) time (t) events (v 1 vocalizations 0 otherwise) individual (gives individual identifier links individuals nest locations)  movement related events move_rate = 0, individuals always located nest, .e. within territory movement. increase movement rate, also increase value movement, standard deviation bivariate Normal kernels centered around nest location. kernel used simulate new locations movement events.  Individuals landscape might different vocalization rates depending , e.g., breeding status. heterogeneity can added simulations finite mixture: vocal_rate move_rate can supplied vector, element giving rate groups. mixture argument used specify mixture proportions.  Vocal movement rates (corresponding kernel standard deviations) can defined four different ways: single number: constant behavior patterns, groups, vector length length(mixture): behavior based finite mixture groups, vector length 3 mixture = 1: mixtures correspond strata, matrix dimension 3 \\(\\times\\) length(mixture): strata \\(\\times\\) number behavior based groups. Strata based groups tracked column s, behavior based groups tracked column g output get_nests. different territory sizes can achieved two-habitat landscape:  Stratum related behavior groups depend nest location. Sometimes makes sense restrict movement even , .e. individuals land certain strata (can cross stratum movement large enough). example, can restrict movement road stratum (requires density 0 stratum):  Another way restrict movement individuals prevent overlap based Voronoi tessellation around nest locations. Note: using update method update allow_overlap argument previous call, plot method deldir package used tessellation.  haven’t mentioned initial_location argument yet. allows override whole layer make individuals fully available layers applied top. .e. possible study observation process without behavioral interference initial_location = TRUE.","code":"l <- bsims_init() p <- bsims_populate(l, density = 0.5) e1 <- bsims_animate(p, vocal_rate = 1)  head(get_events(e1)) #>            x          y           t v   a  i #> 1 -1.0695308 -0.7160919 0.005626468 1 108 10 #> 2  2.4040573  1.3196873 0.022987967 1 314 36 #> 3  1.9208075  2.2174483 0.044264103 1 276 21 #> 4 -1.9400019  1.1727845 0.076256107 1 123  9 #> 5 -2.0071394 -3.4967963 0.084058107 1 178  3 #> 6 -0.6696711 -4.1261427 0.161096144 1  86  6 plot(get_events(e1)) curve((1-exp(-1*x)) * get_abundance(e1), col=2, add=TRUE) e2 <- bsims_animate(p, move_rate = 1, movement = 0.25)  op <- par(mfrow = c(1, 2)) plot(e1, main = \"Closure\") plot(e2, main = \"Movement\") par(op) e3 <- bsims_animate(p,    vocal_rate = c(25, 1), mixture = c(0.33, 0.67))  plot(get_events(e3)) curve((1-0.67*exp(-1*x)) * get_abundance(e3), col=2, add=TRUE) plot(bsims_animate(bsims_populate(l4, density = D),    move_rate = c(0.5, 1, 1), movement = c(0, 0.2, 0.2),    mixture = 1), main=\"Strata based mixtures\") op <- par(mfrow = c(1, 2)) plot(bsims_animate(bsims_populate(l2, density = D),    move_rate = 1, movement = 0.3,    avoid = \"none\"), main=\"Movement not restricted\") plot(bsims_animate(bsims_populate(l2, density = D),    move_rate = 1, movement = 0.3,    avoid = \"R\"), main=\"Movement restricted\") par(op) e4 <- update(e2, allow_overlap=FALSE)  op <- par(mfrow = c(1, 2)) plot(e2, main = \"Overlap\") plot(e2$tess, add=TRUE, wlines=\"tess\",   showpoints=FALSE, cmpnt_lty=1) plot(e4, main = \"No overlap\") plot(e4$tess, add=TRUE, wlines=\"tess\",   showpoints=FALSE, cmpnt_lty=1) par(op)"},{"path":"/articles/bsims02-layers.html","id":"detection","dir":"Articles","previous_headings":"","what":"Detection","title":"Simulation layers in bSims","text":"bsims_detect function detects events created bsims_animate function. bsims_detect returns detections object (class ‘bsims_detections’). argument xy defines location observer landscape. default, middle, can moved anywhere within bounds landscape. tau parameter distance function dist_fun. distance function (\\(g(d)\\)) describes monotonic relationship probability detecting individual decreases distance (\\(d\\)). Detection probability 0 distance 1. commonly used distance function Half-Normal. one-parameter function (\\(g(d) = e^{-(d/\\tau)^2}\\)) probability initially remain high, reflecting increased chance detecting individuals closer observer (\\(\\tau^2\\) variance unfolded Normal distribution, \\(\\tau^2/2\\) variance Half-Normal distribution). Run run_app(\"distfunH\") launch shiny app explore different distance functions, like Hazard rate. distance function must take distance d 1st argument parameter tau second argument (arguments can passed well). E.g. default function(d, tau) exp(-(d/tau)^2), Hazard rate function can written function(d, tau, b=2) 1-exp(-(d/tau)^-b). Individuals detected via auditory visual cues related vocalization movement events, respectively. event_type argument determines kinds events can detected, vocalization, movement, . Detection refers Bernoulli process probability \\(g(d)\\) given actual linear distance individual time observer. get_detections function extracts events detected, column d contains distances (100 m units).  tau argument can vector length 3, referring detection distances strata. landscape stratified, detection distances different among strata bsims_detect function uses segmented attenuation model along linear distance bird observer. run_app(\"distfunHER\") shiny explores segmented attenuation.   notice plot , detections (lines connecting observer location events detected) 2 different colors. ’s allowed vocalization movement event types detected via event_type = \"\" argument. Vocalization movement related detections might different detection function characteristics. flyover might seen larger distances, can also depend body size coloration relative background. reason, tau argument can also vector length 2 provide parameters vocalization (1st value) movement (2nd value) related events. Let’s use e2 object (landscape stratification) see many individuals hear (seen), seen (heard), heard & seen:  tau given \\(3 \\times 2\\) matrix combines strata (rows) vocalization/movement (columns) related parameters, thus allowing distance function differ among three strata distinguish event types. sensitivity argument modifies tau (tau * sensitivity), can specified movement vocal events.didactic way introducing observer sensor related variability detection process. still physical process affected perception.","code":"(d1 <- bsims_detect(e2, tau = 2)) #> bSims detections #>   1 km x 1 km #>   stratification: H #>   total abundance: 43 #>   duration: 10 min #>   detected: 14 heard  head(get_detections(d1)) #>             x          y         t v   a         d  f  i  j #> 59   1.033834 -0.5436307 0.6992886 1 248 1.1680526 NA 37 37 #> 67  -1.473937  1.0003945 0.7579134 1 350 1.7813703 NA 12 12 #> 70   1.033834 -0.5436307 0.8413722 1 234 1.1680526 NA 37 37 #> 91  -1.088111 -0.3823201 1.1195392 1 287 1.1533228 NA 10 10 #> 104 -2.237350 -1.1170397 1.2695494 1 247 2.5007026 NA  1  1 #> 156  0.751192 -0.5472666 1.8167910 1 143 0.9294032 NA 37 37 plot(d1) tau <- c(1, 2, 3, 2, 1) d <- seq(0, 4, 0.01) dist_fun <- function(d, tau) exp(-(d/tau)^2) # half normal #dist_fun <- function(d, tau) exp(-d/tau) # exponential #dist_fun <- function(d, tau) 1-exp(-(d/tau)^-2) # hazard rate  b <- c(0.5, 1, 1.5, 2) #  boundaries  op <- par(mfrow=c(2, 1)) plot(d, dist_fun2(d, tau[1], dist_fun), type=\"n\",   ylab=\"g(d)\", xlab=\"d (100 m)\", axes=FALSE,   main=\"Sound travels from left to right\") axis(1) axis(2) for (i in seq_len(length(b)+1)) {   x1 <- c(0, b, 4)[i]   x2 <- c(0, b, 4)[i+1]   polygon(c(0, b, 4)[c(i, i, i+1, i+1)], c(0, 1, 1, 0),     border=NA,     col=c(\"darkolivegreen1\", \"burlywood1\", \"lightgrey\",     \"burlywood1\", \"darkolivegreen1\")[i]) } lines(d, dist_fun2(d, tau[1], dist_fun)) lines(d, dist_fun2(d, tau[2], dist_fun)) lines(d, dist_fun2(d, tau[3], dist_fun)) lines(d, dist_fun2(d, tau, dist_fun, b), col=2, lwd=3)  plot(rev(d), dist_fun2(d, tau[1], dist_fun), type=\"n\",   ylab=\"g(d)\", xlab=\"d (100 m)\", axes=FALSE,   main=\"Sound travels from right to left\") axis(1) axis(2) for (i in seq_len(length(b)+1)) {   x1 <- c(0, b, 4)[i]   x2 <- c(0, b, 4)[i+1]   polygon(c(0, b, 4)[c(i, i, i+1, i+1)], c(0, 1, 1, 0),     border=NA,     col=c(\"darkolivegreen1\", \"burlywood1\", \"lightgrey\",     \"burlywood1\", \"darkolivegreen1\")[i]) } lines(rev(d), dist_fun2(d, tau[1], dist_fun)) lines(rev(d), dist_fun2(d, tau[2], dist_fun)) lines(rev(d), dist_fun2(d, tau[3], dist_fun)) lines(rev(d), dist_fun2(d, tau, dist_fun, rev(4-b)), col=2, lwd=3) par(op) e5 <- bsims_animate(   bsims_populate(     bsims_init(road = 0.2, edge = 0.4), density = D),    move_rate = 1, movement = 0.2) (d2 <- bsims_detect(e5, tau = c(1, 2, 3), event_type = \"both\")) #> bSims detections #>   1 km x 1 km #>   stratification: HER #>   total abundance: 169 #>   duration: 10 min #>   detected: 42 seen/heard  head(get_detections(d2)) #>             x           y          t v   a         d  f  i  j #> 5  -0.9776217  1.36502323 0.01223095 0  NA 1.6789975 NA 13 13 #> 18  0.7590823 -0.09204728 0.04171113 1  20 0.7646429 NA 93 93 #> 32  0.7199966 -0.18819715 0.08127040 0  NA 0.7441863 NA 93 93 #> 37 -1.5615347  0.99025837 0.09535332 1 352 1.8490544 NA  6  6 #> 43 -0.5873458  0.67553887 0.11854136 0  NA 0.8951692 NA 33 33 #> 80  0.7199966 -0.18819715 0.24575458 1 124 0.7441863 NA 93 93 plot(d2) (d3 <- bsims_detect(e2, tau = c(1.5, 3), event_type = \"both\")) #> bSims detections #>   1 km x 1 km #>   stratification: H #>   total abundance: 43 #>   duration: 10 min #>   detected: 30 seen/heard  dtab <- get_detections(d3) tmp <- with(dtab, table(i, v)) c(\"heard\"=sum(tmp[,\"0\"] == 0 & tmp[,\"1\"] > 0),   \"seen\"=sum(tmp[,\"0\"] > 0 & tmp[,\"1\"] == 0),   \"heard & seen\"=sum(tmp[,\"0\"] > 0 & tmp[,\"1\"] > 0)) #>        heard         seen heard & seen  #>            1           23            6  plot(d3)"},{"path":"/articles/bsims02-layers.html","id":"transcription","dir":"Articles","previous_headings":"","what":"Transcription","title":"Simulation layers in bSims","text":"last layer simulation bsims_transcribe function transcribes detections created bsims_detect function. bsims_transcribe returns detections object (class ‘bsims_transcript’). layer refers process observer assigning detected individuals time distance categories. tint argument vector containing endpoints time intervals within total duration minutes. rint defines distance bands 100 m units, maximum can infinite referring unlimited distance count. error argument refers distance estimation error. impact actual distance bird observer, can lead misclassification distance interval individual assigned. argument log scale standard deviation lognormally distributed random variable representing error. condition argument defines events transcribed: \"event1\" refers 1st event (detected ), \"det1\" refers 1st detection, \"alldet\" means detections (possibly counting individual multiple times). event_type argument can redefined , . perception creates individual identifiers perceived observer. argument defines perceived number individuals relative actual number individuals. can non-negative number (<1 values lead counting, >1 values lead counting), NULL (observer correctly identifies individuals). algorithm uses event based locations hierarchical clustering. dendrogram cut height corresponding specified perception level group membership used individual identifier. bsims_transcribe eventually prepares ‘removal’ table counts new individuals time/distance interval. table used removal distance sampling. ‘visits’ table counts individuals time distance interval, counting restarts every time interval (.e. just new individuals counted). plot method overlays distance bands representation time intervals.","code":"x <- bsims_transcribe(d1,   tint = c(2, 4, 6, 8, 10),    rint = c(0.5, 1, 1.5, Inf)) x #> bSims transcript #>   1 km x 1 km #>   stratification: H #>   total abundance: 43 #>   duration: 10 min #>   detected: 14 heard #>   1st event detected by breaks: #>     [0, 2, 4, 6, 8, 10 min] #>     [0, 50, 100, 150, Inf m] plot(x) get_table(x, \"removal\") #>          0-2min 2-4min 4-6min 6-8min 8-10min #> 0-50m         0      0      0      0       0 #> 50-100m       0      1      0      0       0 #> 100-150m      2      0      0      0       0 #> 150+m         2      0      0      0       0 get_table(x, \"visits\") #>          0-2min 2-4min 4-6min 6-8min 8-10min #> 0-50m         0      0      0      0       0 #> 50-100m       0      1      3      0       0 #> 100-150m      2      0      0      1       2 #> 150+m         2      2      3      2       1"},{"path":"/articles/bsims02-layers.html","id":"statistical-validity-of-the-simulations","dir":"Articles","previous_headings":"","what":"Statistical validity of the simulations","title":"Simulation layers in bSims","text":"can test validity simulations assumptions met (default) homogeneous habitat case. set singing rate (phi), detection distance (tau), density (Den) simulations. Density case unrealistically high, using replication single landscape. help estimation.  use detect package fit removal model distance sampling model simulated output. handily implemented estimate method transcription objects. First, estimate singing rate, effective detection distance, density based truncated distance counts: Next, estimate singing rate, effective detection distance, density based unlimited distance counts: Deviations assumptions bias density estimation can done systematically evaluating simulations settings, describe next section.","code":"phi <- 0.5 # singing rate tau <- 2   # detection distance Den <- 10  # density  set.seed(1) l <- bsims_init() a <- bsims_populate(l, density=Den) b <- bsims_animate(a, vocal_rate=phi) o <- bsims_detect(b, tau=tau)  tint <- c(1, 2, 3, 4, 5) rint <- c(0.5, 1, 1.5, 2) # truncated at 200 m (x <- bsims_transcribe(o, tint=tint, rint=rint)) #> bSims transcript #>   1 km x 1 km #>   stratification: H #>   total abundance: 1014 #>   duration: 10 min #>   detected: 289 heard #>   1st event detected by breaks: #>     [0, 1, 2, 3, 4, 5 min] #>     [0, 50, 100, 150, 200 m] (y <- get_table(x, \"removal\")) # binned new individuals #>          0-1min 1-2min 2-3min 3-4min 4-5min #> 0-50m         1      4      1      1      1 #> 50-100m      10      5      3      0      1 #> 100-150m      9      5      4      2      0 #> 150-200m     12      5      4      1      1 colSums(y) #> 0-1min 1-2min 2-3min 3-4min 4-5min  #>     32     19     12      4      3 rowSums(y) #>    0-50m  50-100m 100-150m 150-200m  #>        8       19       20       23 plot(x) library(detect) #> Loading required package: Formula #> Loading required package: stats4 #> Loading required package: pbapply #> detect 0.4-5      2022-11-07 cbind(true = c(phi=phi, tau=tau, D=Den),    estimate = estimate(x)) #>     true  estimate #> phi  0.5 0.5979187 #> tau  2.0 1.8996806 #> D   10.0 9.7047484 rint <- c(0.5, 1, 1.5, 2, Inf) # unlimited  (x <- bsims_transcribe(o, tint=tint, rint=rint)) #> bSims transcript #>   1 km x 1 km #>   stratification: H #>   total abundance: 1014 #>   duration: 10 min #>   detected: 289 heard #>   1st event detected by breaks: #>     [0, 1, 2, 3, 4, 5 min] #>     [0, 50, 100, 150, 200, Inf m] (y <- get_table(x, \"removal\")) # binned new individuals #>          0-1min 1-2min 2-3min 3-4min 4-5min #> 0-50m         1      4      1      1      1 #> 50-100m      10      5      3      0      1 #> 100-150m      9      5      4      2      0 #> 150-200m     12      5      4      1      1 #> 200+m        15      9      6      1      3 colSums(y) #> 0-1min 1-2min 2-3min 3-4min 4-5min  #>     47     28     18      5      6 rowSums(y) #>    0-50m  50-100m 100-150m 150-200m    200+m  #>        8       19       20       23       34  cbind(true = c(phi=phi, tau=tau, D=Den),    estimate = estimate(x)) #>     true  estimate #> phi  0.5 0.5731308 #> tau  2.0 1.8922130 #> D   10.0 9.8040797"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Peter Solymos. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Solymos P (2022). bSims: Bird Point Count Simulator. R package version 0.3-1, https://github.com/psolymos/bSims.","code":"@Manual{,   title = {bSims: Bird Point Count Simulator},   author = {Peter Solymos},   year = {2022},   note = {R package version 0.3-1},   url = {https://github.com/psolymos/bSims}, }"},{"path":"/index.html","id":"bsims-bird-point-count-simulator-","dir":"","previous_headings":"","what":"Bird Point Count Simulator","title":"Bird Point Count Simulator","text":"highly scientific utterly addictive bird point count simulator test statistical assumptions aid survey design.  “’ve yet see problem, however complicated, looked right way didn’t become still complicated.” – Poul Anderson, Call Joe “Love simulation ’re dreaming ” - Dua Lipa, Physical goal package : test statistical assumptions, aid survey design, fun ! Design objectives: small (point count) scale implementation, habitat considered homogeneous except edge effects, realistic efficient implementation biological mechanisms observation process, defaults chosen reflect common practice assumptions, extensible (PRs welcome). See package action QPAD Book. Check QPAD workshop.","code":""},{"path":"/index.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"Bird Point Count Simulator","text":"CRAN version: Development version: See new NEWS file.","code":"install.packages(\"bSims\") remotes::install_github(\"psolymos/bSims\")"},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Bird Point Count Simulator","text":"GPL-2","code":""},{"path":"/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bird Point Count Simulator","text":"Feedback contributions welcome: submit feature request report issues , fork project submit pull request, see CoC.","code":""},{"path":[]},{"path":"/index.html","id":"command-line","dir":"","previous_headings":"Examples","what":"Command line","title":"Bird Point Count Simulator","text":"","code":"library(bSims)  phi <- 0.5 tau <- 1:3 dur <- 10 rbr <- c(0.5, 1, 1.5, Inf) tbr <- c(3, 5, 10)  l <- bsims_init(10, 0.5, 1) p <- bsims_populate(l, 1) a <- bsims_animate(p, vocal_rate=phi, duration=dur) o <- bsims_detect(a, tau=tau)  x <- bsims_transcribe(o, tint=tbr, rint=rbr)  get_table(x) #>          0-3min 3-5min 5-10min #> 0-50m         1      0       1 #> 50-100m       2      0       0 #> 100-150m      5      0       0 #> 150+m         5      3       1  head(get_events(a)) #>            x         y          t v  i #> 1 -3.6616422 -1.676053 0.01126843 1 12 #> 2  4.6607856  4.537327 0.02661606 1 96 #> 3 -0.2867919  2.155661 0.05207233 1 47 #> 4  2.6507206 -1.110949 0.06329550 1 69 #> 5  2.1330323 -2.167675 0.11365119 1 72 #> 6  0.4926841 -3.517884 0.12323517 1 45  head(get_detections(o)) #>             x           y          t v         d  i  j #> 3  -0.2867919  2.15566066 0.05207233 1 2.1746546 47 47 #> 10  0.7075451  1.01541218 0.26632984 1 1.2376114 58 58 #> 14  0.5770644 -0.47429169 0.35091111 1 0.7469645 62 62 #> 16  0.4761707 -0.04406422 0.35179595 1 0.4782052 52 52 #> 18  1.0957120 -2.41834073 0.45279692 1 2.6549871 60 60 #> 33  1.0111698  1.82788079 0.87025627 1 2.0889262 57 57"},{"path":"/index.html","id":"shiny-apps","dir":"","previous_headings":"Examples","what":"Shiny apps","title":"Bird Point Count Simulator","text":"Shiny apps come package. can used interactively explore effects different settings. Compare distance functions: Compare simulation settings single landscape:","code":"run_app(\"distfunH\") run_app(\"distfunHER\") run_app(\"bsimsH\") run_app(\"bsimsHER\")"},{"path":"/index.html","id":"replicating-simulations","dir":"","previous_headings":"Examples","what":"Replicating simulations","title":"Bird Point Count Simulator","text":"Interactive sessions can used explore different settings. Settings can copied Shiny apps replicated using bsims_all function: object handy methods: $replicate() function also runs multiple cores:","code":"b <- bsims_all(extent=5, road=1, density=c(1,1,0)) b #> bSims wrapper object with settings: #>   extent : 5 #>   road   : 1 #>   density: 1, 1, 0 b$settings()      # retrieve settings b$new()           # replicate once b$replicate(10)   # replicate 10x library(parallel) b <- bsims_all(density=0.5) B <- 4  # number of runs nc <- 2 # number of cores  ## sequential system.time(bb <- b$replicate(B, cl=NULL)) #>    user  system elapsed  #>   0.790   0.013   0.830  ## parallel clusters cl <- makeCluster(nc) ## note: loading the package is optional system.time(clusterEvalQ(cl, library(bSims))) #>    user  system elapsed  #>   0.001   0.000   1.289 system.time(bb <- b$replicate(B, cl=cl)) #>    user  system elapsed  #>   0.013   0.002   0.655 stopCluster(cl)  ## parallel forking if (.Platform$OS.type != \"windows\") {   system.time(bb <- b$replicate(B, cl=nc)) } #>    user  system elapsed  #>   0.413   0.108   0.544"},{"path":"/reference/acceptreject.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial point process simulator — acceptreject","title":"Spatial point process simulator — acceptreject","text":"Spatial point process simulator based accept/reject algorithm.","code":""},{"path":"/reference/acceptreject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial point process simulator — acceptreject","text":"","code":"acceptreject(n, f = NULL, x0 = 0, x1 = 1, y0 = 0, y1 = 1,   m = 0, maxit = 100, fail = FALSE)"},{"path":"/reference/acceptreject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial point process simulator — acceptreject","text":"n number points generate. f function returning probability (value 0 1) given distance first argument. function generates spatially uniform Poisson point process (complete spatial randomness) NULL. x0, x1, y0, y1 x y ranges (bounding box). m margin width avoiding edge effects. maxit maximum number iterations per point try acceptance happens. fail logical, problem. TRUE gives error, default FALSE gives warning.","code":""},{"path":"/reference/acceptreject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial point process simulator — acceptreject","text":"matrix n rows 2 columns x y coordinates.","code":""},{"path":"/reference/acceptreject.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial point process simulator — acceptreject","text":"Peter Solymos","code":""},{"path":"/reference/acceptreject.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial point process simulator — acceptreject","text":"","code":"## complete spatial randomness plot(acceptreject(100), asp=1)   ## more systematic distance <- seq(0,1,0.01) f <- function(d)   (1-exp(-d^2/0.1^2) + dlnorm(d, 0.2)/dlnorm(exp(0.2-1),0.2)) / 2 op <- par(mfrow = c(1, 2)) plot(distance, f(distance), type=\"l\") plot(acceptreject(100, f, m=1), asp=1)  par(op)  ## more clustered f <- function(d)   exp(-d^2/0.1^2) + 0.5*(1-exp(-d^2/0.4^2)) op <- par(mfrow = c(1, 2)) plot(distance, f(distance), type=\"l\") plot(acceptreject(100, f, m=1), asp=1)  par(op)"},{"path":"/reference/bsims_init.html","id":null,"dir":"Reference","previous_headings":"","what":"bSims simulation functions — bsims_init","title":"bSims simulation functions — bsims_init","text":"Functions initialize, populate, animate, detect, transcribe simulated birds point count.","code":""},{"path":"/reference/bsims_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"bSims simulation functions — bsims_init","text":"","code":"bsims_init(extent = 10, road = 0, edge = 0, offset = 0)  bsims_populate(x, density = 1, abund_fun = NULL, xy_fun = NULL,   margin = 0, maxit = 100, fail = FALSE, ...)  bsims_animate(x, vocal_rate = 1, move_rate = 0, duration = 10,   movement = 0, mixture = 1, avoid = c(\"none\", \"R\", \"ER\"),   initial_location=FALSE, allow_overlap=TRUE, ...)  bsims_detect(x, xy = c(0, 0), tau = 1, dist_fun = NULL,   event_type = c(\"vocal\", \"move\", \"both\"),   sensitivity=1, direction=FALSE, ...)  bsims_transcribe(x, tint = NULL, rint = Inf,   error = 0, bias = 1,   condition=c(\"event1\", \"det1\", \"alldet\"),   event_type=NULL, perception=NULL, ...)  bsims_all(...)  # S3 method for bsims_landscape print(x, ...) # S3 method for bsims_population print(x, ...) # S3 method for bsims_events print(x, ...) # S3 method for bsims_detections print(x, ...) # S3 method for bsims_transcript print(x, ...) # S3 method for bsims_all print(x, ...)"},{"path":"/reference/bsims_init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"bSims simulation functions — bsims_init","text":"extent extent simulation area, extent x extent square (0,0) center. road half width road stratum (perpendicular y axis). edge width edge, width sides road stratum. offset offset apply road edge strata relative center x direction. x simulation object. density population density, D, recycled 3x 3 strata (H: habitat, E: edge, R: road). abund_fun function simulate abundance, N ~ Poisson(lambda), lambda=DA default. xy_fun function used simulate nest locations, see acceptreject. function return probability (value 0 1), NULL means complete spatial randomness. margin, maxit, fail arguments passed acceptreject using xy_fun simulate nest locations. vocal_rate, move_rate Vocal movement rates (see events). rates can : single number; vector length length(mixture) (behavior based finite mixture groups); vector length 3 mixture=1 (corresponding strata); matrix dimension 3 x length(mixture) (strata x number behavior based groups). duration total time duration consider (minutes), passed events. movement standard deviation bivariate Normal kernel simulate locations centered nest location, passed events. Can refer stratum behavior based groups move_rate. mixture behavior based finite mixture group proportions. avoid range along x axis avoid respect movement locations, passed events. initial_location logical, move_rate vocal_rate silently ignored TRUE nest locations provided part events table. renders individuals equally available detection. allow_overlap logical, allowing overlap neighboring nests movement involved. FALSE, Voronoi tessellation used prevent overlap. TRUE, unconstrained bivariate Normal kernel used. xy vector x y coordinates describing position observer. tau parameter distance function. Can single numeric value; vector length 2 provide parameters vocalization (1st value) movement (2nd value) related events; (H: habitat, E: edge, R: road, order); vector length 3 provide parameters 3 strata (H: habitat, E: edge, R: road); 3 x 2 matrix combining strata (rows) vocalization/movement (columns) related parameters. Segmented sound attenuation used values different 3 strata (see dist_fun2). dist_fun distance function (1st argument distance, second tau). event_type type events access (vocal, movement, ). Inherits value input object NULL. tint time interval break points minutes. rint distance interval break points units 100 meter. condition conditioning type define availability individual: \"event1\": 1st event (detected ); \"det1\": 1st detection; \"alldet\": detections (counting individual multiple times). error log scale standard deviation (SD) distance estimation error, see rlnorm2. direction=TRUE, error changes based angle observer individual's (random) singing direction. bird faces observer (0 degrees) SD 0, bird facing away (180 degrees) SD error. range 0-180 degrees SD changing according cosine degree: SD*(0.5-cos(degree*pi/180)/2). bias nonnegative numeric, distance estimation bias. default value (1) means bias, <1 indicates negative bias (perceived distance less true distance), >1 indicates positive bias (perceived distance higher true distance). acts multiplier can combined error. direction=TRUE, bias changes based angle observer individual's (random) singing direction. bird faces observer (0 degrees) perceived distance equals true distance, bird facing away (180 degrees) perceived distance bias * true distance. range 0-180 degrees bias changing according cosine degree: 1+(bias-1)*(0.5-cos(degree*pi/180)/2). perception perceived number individuals relative actual number individuals. non-negative number (<1 values lead counting, >1 values lead counting), NULL (observer correctly identifies individuals). sensitivity non-negative numeric value indicating sensitivity sensor receiving signal. Can length 1 (applies vocal movement events) named vector length 2 (names indicate one \"vocal\" \"move\"). Sensitivity 1 means process captured tau unaffected. Less 1 values indicate lower sensitivity (effectively decreasing tau), larger 1 values indicate higher sensitivity (effectively increasing tau). direction logical. TRUE, tau vocalizations (movement) changes based angle observer individual's (random) singing direction. bird faces observer (0 degrees) tau unaffected, bird facing away (180 degrees) tau sensitivity * tau. range 0-180 degrees effect changing according cosine degree (0.5-cos(degree*pi/180)/2). ... arguments passed underlying functions. bsims_all wrapper, means arguments (except x) underlying bsims_* functions . bsims_all can also take single list argument.","code":""},{"path":"/reference/bsims_init.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"bSims simulation functions — bsims_init","text":"functions capturing simulation layers supposed called sequence, allowing simulate multiple realities keeping preceding layers intact. Construction allows easy piping. bsims_all function wrapper bsims_* layer functions. simulations follow time-removal distance sampling models based Matsuoka et al. (2012) <doi:10.1525/auk.2012.11190>, Solymos et al. (2013) <doi:10.1111/2041-210X.12106>, Solymos et al. (2018) <doi:10.1650/CONDOR-18-32.1>, sound attenuation experiments Yip et al. (2017) <doi:10.1650/CONDOR-16-93.1>.","code":""},{"path":"/reference/bsims_init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"bSims simulation functions — bsims_init","text":"bsims_init returns landscape object. bsims_populate returns population object. bsims_animate returns events object. bsims_detect returns detections object. bsims_transcribe returns transcript object. get_table returns removal table. bsims_all returns closure $settings(), $new(recover = FALSE), $replicate(B, recover = FALSE, cl = NULL) functions. settings function returns input arguments list; new function returns single transcript object; replicate function takes argument number replicates (B) returns list transcript objects B elements. cl argument used parallelize work, can numeric value Unix/Linux/OSX, cluster object OS, see examples. `recover = TRUE` argument allows run simulations error catching based try. Note simulated objects returned bsims_all contain different realizations conditionally independent layers. Use layered approach former layers meant kept identical across runs.","code":""},{"path":"/reference/bsims_init.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"bSims simulation functions — bsims_init","text":"Matsuoka, S. M., Bayne, E. M., Solymos, P., Fontaine, P., Cumming, S. G., Schmiegelow, F. K. ., & Song, S. ., 2012. Using binomial distance-sampling models estimate effective detection radius point-counts surveys across boreal Canada. Auk, 129: 268--282. <doi:10.1525/auk.2012.11190> Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P., Cumming, S. G., Stralberg, D., Schmiegelow, F. K. . & Song, S. J., 2013. Calibrating indices avian density non-standardized survey data: making messy situation. Methods Ecology Evolution, 4: 1047--1058. <doi:10.1111/2041-210X.12106> Solymos, P., Matsuoka, S. M., Cumming, S. G., Stralberg, D., Fontaine, P., Schmiegelow, F. K. ., Song, S. J., Bayne, E. M., 2018. Evaluating time-removal models estimating availability boreal birds point-count surveys: sample size requirements model complexity. Condor, 120: 765--786. <doi:10.1650/CONDOR-18-32.1> Yip, D. ., Bayne, E. M., Solymos, P., Campbell, J., Proppe, J. D., 2017. Sound attenuation forested roadside environments: implications avian point count surveys. Condor, 119: 73--84. <doi:10.1650/CONDOR-16-93.1>","code":""},{"path":"/reference/bsims_init.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"bSims simulation functions — bsims_init","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/bsims_init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"bSims simulation functions — bsims_init","text":"","code":"phi <- 0.5 tau <- 1:3 dur <- 10 rbr <- c(0.5, 1, 1.5, Inf) tbr <- c(3, 5, 10) (l <- bsims_init(10, 0.5, 1)) #> bSims landscape #>   1 km x 1 km #>   stratification: HER (p <- bsims_populate(l, 1)) #> bSims population #>   1 km x 1 km #>   stratification: HER #>   total abundance: 117 (a <- bsims_animate(p, vocal_rate=phi, duration=dur)) #> bSims events #>   1 km x 1 km #>   stratification: HER #>   total abundance: 117 #>   duration: 10 min (o <- bsims_detect(a, tau=tau)) #> bSims detections #>   1 km x 1 km #>   stratification: HER #>   total abundance: 117 #>   duration: 10 min #>   detected: 32 heard (x <- bsims_transcribe(o, tint=tbr, rint=rbr)) #> bSims transcript #>   1 km x 1 km #>   stratification: HER #>   total abundance: 117 #>   duration: 10 min #>   detected: 32 heard #>   1st event detected by breaks: #>     [0, 3, 5, 10 min] #>     [0, 50, 100, 150, Inf m]  plot(x)  get_table(x, \"removal\") #>          0-3min 3-5min 5-10min #> 0-50m         1      0       0 #> 50-100m       0      0       0 #> 100-150m      4      1       0 #> 150+m         9      2       2 get_table(x, \"visits\") #>          0-3min 3-5min 5-10min #> 0-50m         1      1       1 #> 50-100m       0      1       0 #> 100-150m      4      3       5 #> 150+m         9      7      10  head(get_events(a)) #>           x          y         t v   a   i #> 1  2.370007  1.3983154 0.1194229 1 326 113 #> 2  2.883718 -1.4803306 0.1211099 1 219 117 #> 3  2.370007  1.3983154 0.1356055 1  61 113 #> 4  2.085192  3.6936944 0.1395300 1 322 103 #> 5 -4.418766  0.2091038 0.1403604 1 201  45 #> 6 -4.341580 -2.6252934 0.1663730 1 206  42 plot(get_events(a))   head(get_detections(o)) #>             x          y         t v   a        d  f   i   j #> 1   2.3700068  1.3983154 0.1194229 1 326 2.751766 NA 113 113 #> 14 -0.5659587 -1.9962196 0.3722549 1  96 2.074898 NA  57  57 #> 15  2.1794335 -1.2452094 0.3760606 1  98 2.510075 NA 110 110 #> 17 -2.6490673  0.5143298 0.4125239 1 199 2.698535 NA   2   2 #> 19  0.6118683 -1.9209927 0.4398052 1 356 2.016084 NA  79  79 #> 22  1.0453586  0.1477090 0.4614603 1 347 1.055743 NA  82  82 plot(get_detections(o), \"time\")  plot(get_detections(o), \"distance\")   ## wrapper function for all the bsims_* layers b <- bsims_all(road=1, density=0.5, tint=tbr, rint=rbr) ## alternatively: supply a list #settings <- list(road=1, density=0.5, tint=tbr, rint=rbr) #b <- bsims_all(settings) b$settings() #> $road #> [1] 1 #>  #> $density #> [1] 0.5 #>  #> $tint #> [1]  3  5 10 #>  #> $rint #> [1] 0.5 1.0 1.5 Inf #>  b$new() #> bSims transcript #>   1 km x 1 km #>   stratification: HR #>   total abundance: 54 #>   duration: 10 min #>   detected: 2 heard #>   1st event detected by breaks: #>     [0, 3, 5, 10 min] #>     [0, 50, 100, 150, Inf m] bb <- b$replicate(3) lapply(bb, get_table) #> [[1]] #>          0-3min 3-5min 5-10min #> 0-50m         0      0       0 #> 50-100m       1      0       0 #> 100-150m      0      0       0 #> 150+m         2      0       0 #>  #> [[2]] #>          0-3min 3-5min 5-10min #> 0-50m         1      0       0 #> 50-100m       0      0       0 #> 100-150m      0      0       0 #> 150+m         0      0       0 #>  #> [[3]] #>          0-3min 3-5min 5-10min #> 0-50m         0      0       0 #> 50-100m       0      0       0 #> 100-150m      2      0       0 #> 150+m         0      0       0 #>   # \\donttest{ ## parallel simulations library(parallel) b <- bsims_all(density=0.5) B <- 4  # number of runs nc <- 2 # number of cores ## sequential system.time(bb <- b$replicate(B, cl=NULL)) #>    user  system elapsed  #>   0.960   0.003   0.970  ## parallel clusters cl <- makeCluster(nc) ## note: loading the package is optional system.time(clusterEvalQ(cl, library(bSims))) #> Error in checkForRemoteErrors(lapply(cl, recvResult)): 2 nodes produced errors; first error: there is no package called ‘bSims’ #> Timing stopped at: 0.001 0 0.002 system.time(bb <- b$replicate(B, cl=cl)) #> Error in checkForRemoteErrors(lapply(cl, recvResult)): 2 nodes produced errors; first error: there is no package called ‘bSims’ #> Timing stopped at: 0.001 0 0.002 stopCluster(cl) ## parallel forking if (.Platform$OS.type != \"windows\") {   system.time(bb <- b$replicate(B, cl=nc)) } #>    user  system elapsed  #>   0.008   0.012   0.966  # }"},{"path":"/reference/dist_fun2.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance function with segmented attenuation — dist_fun2","title":"Distance function with segmented attenuation — dist_fun2","text":"Distance function segmented attenuation crossing number boundaries strata different attenuation characteristics following results Yip et al. (2017).","code":""},{"path":"/reference/dist_fun2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance function with segmented attenuation — dist_fun2","text":"","code":"dist_fun2(d, tau, dist_fun, breaks = numeric(0), ...)"},{"path":"/reference/dist_fun2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance function with segmented attenuation — dist_fun2","text":"d distance observer. tau parameter passed distance function. Length tau must equal length(b) + 1 referring distance function parameters different strata (stratum defined interval surrounded 1 2 boundaries). dist_fun distance function taking two arguments: distance, tau, see examples. breaks distance breakpoints, must length(tau) - 1 length. breakpoints represent boundaries intervals characterized homogeneous attenuation characteristics. ... arguments passed dist_fun","code":""},{"path":"/reference/dist_fun2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance function with segmented attenuation — dist_fun2","text":"Probability detection given distance, stratum specific parameters arrangement breakpoints.","code":""},{"path":"/reference/dist_fun2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distance function with segmented attenuation — dist_fun2","text":"Yip, D. ., Bayne, E. M., Solymos, P., Campbell, J., Proppe, J. D., 2017. Sound attenuation forested roadside environments: implications avian point count surveys. Condor, 119: 73--84. <doi:10.1650/CONDOR-16-93.1>","code":""},{"path":"/reference/dist_fun2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance function with segmented attenuation — dist_fun2","text":"Peter Solymos","code":""},{"path":"/reference/dist_fun2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance function with segmented attenuation — dist_fun2","text":"","code":"tau <- c(1, 2, 3, 2, 1) d <- seq(0, 4, 0.01) dist_fun <- function(d, tau) exp(-(d/tau)^2) # half normal #dist_fun <- function(d, tau) exp(-d/tau) # exponential #dist_fun <- function(d, tau) 1-exp(-(d/tau)^-2) # hazard rate  b <- c(0.5, 1, 1.5, 2) #  boundaries  op <- par(mfrow=c(2, 1)) plot(d, dist_fun2(d, tau[1], dist_fun), type=\"n\",   ylab=\"P(detection)\", xlab=\"Distance\", axes=FALSE,   main=\"Sound travels from left to right\") axis(1) axis(2) for (i in seq_len(length(b)+1)) {   x1 <- c(0, b, 4)[i]   x2 <- c(0, b, 4)[i+1]   polygon(c(0, b, 4)[c(i, i, i+1, i+1)], c(0, 1, 1, 0),     border=NA,     col=c(\"darkolivegreen1\", \"burlywood1\", \"lightgrey\",     \"burlywood1\", \"darkolivegreen1\")[i]) } lines(d, dist_fun2(d, tau[1], dist_fun)) lines(d, dist_fun2(d, tau[2], dist_fun)) lines(d, dist_fun2(d, tau[3], dist_fun)) lines(d, dist_fun2(d, tau, dist_fun, b), col=2, lwd=3)  plot(rev(d), dist_fun2(d, tau[1], dist_fun), type=\"n\",   ylab=\"P(detection)\", xlab=\"Distance\", axes=FALSE,   main=\"Sound travels from right to left\") axis(1) axis(2) for (i in seq_len(length(b)+1)) {   x1 <- c(0, b, 4)[i]   x2 <- c(0, b, 4)[i+1]   polygon(c(0, b, 4)[c(i, i, i+1, i+1)], c(0, 1, 1, 0),     border=NA,     col=c(\"darkolivegreen1\", \"burlywood1\", \"lightgrey\",     \"burlywood1\", \"darkolivegreen1\")[i]) } lines(rev(d), dist_fun2(d, tau[1], dist_fun)) lines(rev(d), dist_fun2(d, tau[2], dist_fun)) lines(rev(d), dist_fun2(d, tau[3], dist_fun)) lines(rev(d), dist_fun2(d, tau, dist_fun, rev(4-b)), col=2, lwd=3)  par(op)"},{"path":"/reference/estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate basic parameters — estimate","title":"Estimate basic parameters — estimate","text":"Estimate singing rates, effective distances, density based simulation objects using QPAD approach (Solymos et al. 2013).","code":""},{"path":"/reference/estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate basic parameters — estimate","text":"","code":"estimate(object, ...) # S3 method for bsims_transcript estimate(object, ...)"},{"path":"/reference/estimate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate basic parameters — estimate","text":"object simulation object. ... arguments passed internal functions.","code":""},{"path":"/reference/estimate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate basic parameters — estimate","text":"method evaluates removal design estimate model parameters density using QPAD methodology using 'detect' package. function works multiple time distance intervals. returns NA otherwise.","code":""},{"path":"/reference/estimate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate basic parameters — estimate","text":"vector values singing rate (phi), effective detection distance (tau), density.","code":""},{"path":"/reference/estimate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate basic parameters — estimate","text":"Solymos, P., Matsuoka, S. M., Bayne, E. M., Lele, S. R., Fontaine, P., Cumming, S. G., Stralberg, D., Schmiegelow, F. K. . & Song, S. J., 2013. Calibrating indices avian density non-standardized survey data: making messy situation. Methods Ecology Evolution, 4: 1047--1058. <doi:10.1111/2041-210X.12106>","code":""},{"path":"/reference/estimate.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate basic parameters — estimate","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/estimate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate basic parameters — estimate","text":"","code":"set.seed(2) phi <- 0.5                 # singing rate tau <- 1                   # EDR by strata dur <- 10                  # simulation duration tbr <- c(2, 4, 6, 8, 10)   # time intervals rbr <- c(0.5, 1, 1.5, Inf) # counting radii  l <- bsims_init(10, 0.5, 1)# landscape p <- bsims_populate(l, 10)  # population e <- bsims_animate(p,      # events   vocal_rate=phi, duration=dur) d <- bsims_detect(e,       # detections   tau=tau) x <- bsims_transcribe(d,   # transcription   tint=tbr, rint=rbr)  estimate(x) #>        phi        tau    density  #>  0.4754889  0.9051818 11.3640146"},{"path":"/reference/events.html","id":null,"dir":"Reference","previous_headings":"","what":"Event time simulator — events","title":"Event time simulator — events","text":"timetoevent turns exponential wait times time--event data within desired duration, handles 0 infinite rates robust manner. events simulates event times based exponential time--event distribution.","code":""},{"path":"/reference/events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Event time simulator — events","text":"","code":"timetoevent(rate, duration)  events(vocal_rate = 1, move_rate = 1, duration = 10,   movement = 0, avoid = c(0, 0))"},{"path":"/reference/events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Event time simulator — events","text":"rate rate exponential distribution (rexp). duration total time duration consider (minutes). vocal_rate vocal rate exponential distribution (rexp), often vocal event happens per minute. move_rate movement rate exponential distribution (rexp), often movement event happens per minute. movement standard deviation bivariate Normal kernel simulate locations centered nest location. avoid range along x axis avoid respect movement locations, .e. location movement event within interval rejected new location drawn.","code":""},{"path":"/reference/events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Event time simulator — events","text":"events object data frame coordinates (x, y; centered 0 nest location), event times (t) indicator vocal events (v).","code":""},{"path":"/reference/events.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Event time simulator — events","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/events.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Event time simulator — events","text":"","code":"timetoevent(0, 10) #> numeric(0) timetoevent(Inf, 10) #> [1] 0  rr <- 1 tt <- timetoevent(rr, 10) op <- par(mfrow=c(1,2)) plot(ecdf(tt)) curve(1-exp(-rr*x), add=TRUE, col=2) # cdf  plot(stepfun(sort(tt), 0:length(tt)/length(tt)), ylab=\"F(x)\") curve(1-exp(-rr*x), add=TRUE, col=2) # cdf  par(op)  e <- events(movement=1, duration=60) mx <- max(abs(e[,1:2])) plot(e[,1:2], col=\"grey\", type=\"l\", asp=1,   xlim=2*c(-mx, mx), ylim=2*c(-mx, mx)) points(e[,1:2], col=e$v+1) abline(h=0, v=0, lty=2) legend(\"topright\", pch=21, col=1:2, horiz=TRUE,   legend=c(\"movement\", \"vocalization\"))"},{"path":"/reference/expand_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list from all combinations of arguments — expand_list","title":"Create a list from all combinations of arguments — expand_list","text":"Create list combinations supplied vectors lists.","code":""},{"path":"/reference/expand_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list from all combinations of arguments — expand_list","text":"","code":"expand_list(...)"},{"path":"/reference/expand_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list from all combinations of arguments — expand_list","text":"... vectors lists. arguments must named.","code":""},{"path":"/reference/expand_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a list from all combinations of arguments — expand_list","text":"list containing one element combination supplied vectors lists. first factors vary fastest. nested elements labeled factors. function allows list elements vectors, functions, NULL. vector element supposed kept vector, use list().","code":""},{"path":"/reference/expand_list.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a list from all combinations of arguments — expand_list","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/expand_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a list from all combinations of arguments — expand_list","text":"","code":"b <- expand_list(   movement = c(0, 1, 2),   rint = list(c(0.5, 1, 1.5, Inf)), # in a list to keep as one   xy_fun = list(NULL, function(z) z)) b[[1]] #> $movement #> [1] 0 #>  #> $rint #> [1] 0.5 1.0 1.5 Inf #>  #> $xy_fun #> NULL #>  str(b) #> List of 6 #>  $ :List of 3 #>   ..$ movement: num 0 #>   ..$ rint    : num [1:4] 0.5 1 1.5 Inf #>   ..$ xy_fun  : NULL #>  $ :List of 3 #>   ..$ movement: num 1 #>   ..$ rint    : num [1:4] 0.5 1 1.5 Inf #>   ..$ xy_fun  : NULL #>  $ :List of 3 #>   ..$ movement: num 2 #>   ..$ rint    : num [1:4] 0.5 1 1.5 Inf #>   ..$ xy_fun  : NULL #>  $ :List of 3 #>   ..$ movement: num 0 #>   ..$ rint    : num [1:4] 0.5 1 1.5 Inf #>   ..$ xy_fun  :function (z)   #>   .. ..- attr(*, \"srcref\")= 'srcref' int [1:8] 4 23 4 35 23 35 4 4 #>   .. .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7fa3e9ad40a8>  #>  $ :List of 3 #>   ..$ movement: num 1 #>   ..$ rint    : num [1:4] 0.5 1 1.5 Inf #>   ..$ xy_fun  :function (z)   #>   .. ..- attr(*, \"srcref\")= 'srcref' int [1:8] 4 23 4 35 23 35 4 4 #>   .. .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7fa3e9ad40a8>  #>  $ :List of 3 #>   ..$ movement: num 2 #>   ..$ rint    : num [1:4] 0.5 1 1.5 Inf #>   ..$ xy_fun  :function (z)   #>   .. ..- attr(*, \"srcref\")= 'srcref' int [1:8] 4 23 4 35 23 35 4 4 #>   .. .. ..- attr(*, \"srcfile\")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7fa3e9ad40a8>"},{"path":"/reference/getters.html","id":null,"dir":"Reference","previous_headings":"","what":"Access nests, events, detections, and totals — get_nests","title":"Access nests, events, detections, and totals — get_nests","text":"Access nests, events, detections, abundance, density simulation objects.","code":""},{"path":"/reference/getters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access nests, events, detections, and totals — get_nests","text":"","code":"get_nests(x, ...) # S3 method for bsims_population get_nests(x, ...)  get_events(x, ...) # S3 method for bsims_events get_events(x, ...)  get_detections(x, ...) # S3 method for bsims_detections get_detections(x, ...)  get_abundance(x, ...) # S3 method for bsims_population get_abundance(x, ...)  get_density(x, ...) # S3 method for bsims_population get_density(x, ...)  get_table(x, ...) # S3 method for bsims_transcript get_table(x,   type = c(\"removal\", \"visits\"), ...)"},{"path":"/reference/getters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access nests, events, detections, and totals — get_nests","text":"x simulation object. type character, type table return: \"removal\" includes new individuals time progresses, \"visits\" counts individuals time interval independent . ... arguments passed internal functions.","code":""},{"path":"/reference/getters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Access nests, events, detections, and totals — get_nests","text":"get_nests extracts next locations. get_events extracts events. get_detections extracts detections. get_abundance gets realized total abundance (N), get_density gets realized average density (abundance/area: N/). get_table returns removal visits table.","code":""},{"path":"/reference/getters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access nests, events, detections, and totals — get_nests","text":"get_abundance get_density returns non-negative numeric value. get_nests returns data frame following columns: individual identifier, s spatial stratum (H: habitat, E: edge, R: road) x y coordinates nest locations, g behavioral (mixture) group NA. get_events returns data frame following columns: x y locations individual time event, t time event within duration interval, v indicator variable vocal (1) vs. movement (0) event, individual identifier. get_detections returns data frame following columns: x y locations individual time event, t time event within duration interval, v indicator variable vocal (1) vs. movement (0) event, d distance observer detected (otherwise NA). individual identifier, j perceived individual identifier. get_table returns matrix distance bands rows time intervals columns. cell values counts individuals detected removal fashion (new individuals counter time periods) multiple-visits fashion (counting individuals restarts every time interval).","code":""},{"path":"/reference/getters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Access nests, events, detections, and totals — get_nests","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/getters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access nests, events, detections, and totals — get_nests","text":"","code":"phi <- 0.5                 # singing rate tau <- 1:3                 # EDR by strata dur <- 10                  # simulation duration tbr <- c(3, 5, 10)         # time intervals rbr <- c(0.5, 1, 1.5, Inf) # counting radii  l <- bsims_init(10, 0.5, 1)# landscape p <- bsims_populate(l, 1)  # population e <- bsims_animate(p,      # events   vocal_rate=phi, duration=dur) d <- bsims_detect(e,       # detections   tau=tau) x <- bsims_transcribe(d,   # transcription   tint=tbr, rint=rbr)  ## next locations head(get_nests(p)) #>   i s         x          y  g #> 1 1 H -4.315038 -1.9201875 NA #> 2 2 H -2.462982 -4.3714492 NA #> 3 3 H -1.806481 -1.9443110 NA #> 4 4 H -2.811867  4.6403058 NA #> 5 5 H -4.031108 -4.4926347 NA #> 6 6 H -1.992186  0.1235921 NA head(get_nests(e)) #>   i s         x          y  g #> 1 1 H -4.315038 -1.9201875 G1 #> 2 2 H -2.462982 -4.3714492 G1 #> 3 3 H -1.806481 -1.9443110 G1 #> 4 4 H -2.811867  4.6403058 G1 #> 5 5 H -4.031108 -4.4926347 G1 #> 6 6 H -1.992186  0.1235921 G1 head(get_nests(d)) #>   i s         x          y  g #> 1 1 H -4.315038 -1.9201875 G1 #> 2 2 H -2.462982 -4.3714492 G1 #> 3 3 H -1.806481 -1.9443110 G1 #> 4 4 H -2.811867  4.6403058 G1 #> 5 5 H -4.031108 -4.4926347 G1 #> 6 6 H -1.992186  0.1235921 G1 head(get_nests(x)) #>   i s         x          y  g #> 1 1 H -4.315038 -1.9201875 G1 #> 2 2 H -2.462982 -4.3714492 G1 #> 3 3 H -1.806481 -1.9443110 G1 #> 4 4 H -2.811867  4.6403058 G1 #> 5 5 H -4.031108 -4.4926347 G1 #> 6 6 H -1.992186  0.1235921 G1  ## abundance get_abundance(p) #> [1] 95 get_abundance(e) #> [1] 95 get_abundance(d) #> [1] 95 get_abundance(x) #> [1] 95  ## density get_density(p) #> [1] 0.95 get_density(e) #> [1] 0.95 get_density(d) #> [1] 0.95 get_density(x) #> [1] 0.95  ## events head(get_events(e)) #>            x          y          t v   a  i #> 1 -0.3738905  0.1742159 0.00480860 1   0 44 #> 2  3.4598208 -3.0812244 0.01074640 1 156 89 #> 3 -2.2047155 -3.9809563 0.02045773 1 284 34 #> 4  2.8201059  3.0568185 0.02574542 1 336 82 #> 5  2.8591436 -1.0125381 0.02627925 1 193 90 #> 6 -1.1423269  1.5779129 0.02695094 1 327 43 head(get_events(d)) #>            x          y          t v   a  f  i #> 1 -0.3738905  0.1742159 0.00480860 1   0 NA 44 #> 2  3.4598208 -3.0812244 0.01074640 1 156 NA 89 #> 3 -2.2047155 -3.9809563 0.02045773 1 284 NA 34 #> 4  2.8201059  3.0568185 0.02574542 1 336 NA 82 #> 5  2.8591436 -1.0125381 0.02627925 1 193 NA 90 #> 6 -1.1423269  1.5779129 0.02695094 1 327 NA 43 head(get_events(x)) #>            x          y          t v   a  f  i #> 1 -0.3738905  0.1742159 0.00480860 1   0 NA 44 #> 2  3.4598208 -3.0812244 0.01074640 1 156 NA 89 #> 3 -2.2047155 -3.9809563 0.02045773 1 284 NA 34 #> 4  2.8201059  3.0568185 0.02574542 1 336 NA 82 #> 5  2.8591436 -1.0125381 0.02627925 1 193 NA 90 #> 6 -1.1423269  1.5779129 0.02695094 1 327 NA 43  ## detections head(get_detections(d)) #>              x          y          t v   a         d  f  i  j #> 1  -0.37389047  0.1742159 0.00480860 1   0 0.4124867 NA 44 44 #> 7  -0.95018898  1.5035194 0.07937606 1  38 1.7786033 NA 41 41 #> 15  0.07908970 -0.4709415 0.17878431 1  28 0.4775365 NA 45 45 #> 17  0.72543673  1.4485678 0.20332589 1 164 1.6200639 NA 65 65 #> 18  1.01222174  1.7485858 0.20601417 1  25 2.0204319 NA 62 62 #> 21  0.05090871 -3.1189755 0.31610480 1 166 3.1193909 NA 50 50 head(get_detections(x)) #>              x          y          t v   a         d  f  i  j #> 1  -0.37389047  0.1742159 0.00480860 1   0 0.4124867 NA 44 44 #> 7  -0.95018898  1.5035194 0.07937606 1  38 1.7786033 NA 41 41 #> 15  0.07908970 -0.4709415 0.17878431 1  28 0.4775365 NA 45 45 #> 17  0.72543673  1.4485678 0.20332589 1 164 1.6200639 NA 65 65 #> 21  0.05090871 -3.1189755 0.31610480 1 166 3.1193909 NA 50 50 #> 27 -1.99218646  0.1235921 0.39815399 1 330 1.9960165 NA  6  6  get_table(x, \"removal\") #>          0-3min 3-5min 5-10min #> 0-50m         2      0       0 #> 50-100m       0      0       0 #> 100-150m      2      0       0 #> 150+m        10      0       0 get_table(x, \"visits\") #>          0-3min 3-5min 5-10min #> 0-50m         2      1       2 #> 50-100m       0      0       0 #> 100-150m      2      1       2 #> 150+m        10      1      10"},{"path":"/reference/internals.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — internals","title":"Internal functions — internals","text":"Internal functions intended used user.","code":""},{"path":"/reference/internals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — internals","text":"","code":".get_events(x, event_type=c(\"vocal\", \"move\", \"both\"), tlim = NULL)  .get_detections(x, condition = c(\"event1\", \"det1\", \"alldet\"),   event_type = c(\"vocal\", \"move\", \"both\"), tlim = NULL,   perception = NULL)  .bsims_all(Settings)"},{"path":"/reference/internals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — internals","text":"x simulation object. event_type type events access. condition conditioning type define availability individual: \"event1\": 1st event (detected ); \"det1\": 1st detection; \"alldet\": detections (counting individual multiple times). tlim time intervals treated [min(tlim), max(tlim)). perception perceived number individuals relative actual number individuals. non-negative number (<1 values lead counting, >1 values lead counting), NULL (observer correctly identifies individuals). Settings list arguments.","code":""},{"path":"/reference/plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot methods — plot.bsims_landscape","title":"Plot methods — plot.bsims_landscape","text":"Plot methods different bSims objects.","code":""},{"path":"/reference/plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot methods — plot.bsims_landscape","text":"","code":"# S3 method for bsims_landscape plot(x,   col_H, col_E, col_R,   xlim = NULL, ylim = NULL, ...)  # S3 method for bsims_population plot(x,   pch_nest, col_nest, cex_nest, ...)  # S3 method for bsims_events plot(x,   event_type=c(\"vocal\", \"move\", \"both\"), tlim = NULL,   pch_nest, col_nest, cex_nest,   pch_vocal, col_vocal, cex_vocal,   lty_move, col_move, lwd_move, ...)  # S3 method for bsims_detections plot(x,   event_type=NULL, tlim = NULL,   pch_nest, col_nest, cex_nest,   pch_vocal, col_vocal, cex_vocal,   lty_move, col_move, lwd_move,   lty_det_vocal, col_det_vocal, lwd_det_vocal,   lty_det_move, col_det_move, lwd_det_move,   condition = \"event1\", ...)  # S3 method for bsims_transcript plot(x,   pch_nest, col_nest, cex_nest,   pch_vocal, col_vocal, cex_vocal,   lty_move, col_move, lwd_move,   lty_det_vocal, col_det_vocal, lwd_det_vocal,   lty_det_move, col_det_move, lwd_det_move,   show_tint=TRUE, show_rint=TRUE,   col_tint, col_rint, ...)  # S3 method for bsims_events lines(x, tlim = NULL, ...) # S3 method for bsims_detections lines(x,   event_type=NULL, tlim=NULL, condition=\"event1\", ...) # S3 method for bsims_transcript lines(x,   event_type=NULL, tlim=NULL, ...)  # S3 method for bsims_population points(x, ...) # S3 method for bsims_events points(x,   event_type=c(\"vocal\", \"move\", \"both\"), tlim = NULL, ...) # S3 method for bsims_detections points(x,   event_type=NULL, tlim=NULL, condition=\"event1\", ...)  col2hex(col, alpha = FALSE)  # S3 method for bsims_events_table plot(x,   xlab, ylab, xlim, ylim, col_det_vocal, col_det_move, ...) # S3 method for bsims_detections_table plot(x,   type=c(\"time\", \"distance\"), xlab, ylab, xlim, ylim,   col_det_vocal, col_det_move, ...)"},{"path":"/reference/plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot methods — plot.bsims_landscape","text":"x simulation object. col color values. col_H, col_E, col_R color values Habitat, Edge, Road strata. event_type type events access. value inferred input object NULL. xlim, ylim, tlim x, y, time intervals. xlab, ylab x y axis labels. pch_nest, col_nest, cex_nest visual characteristics nest locations. pch_vocal, col_vocal, cex_vocal visual characteristics vocalization events. lty_move, col_move, lwd_move visual characteristics movement events. lty_det_vocal, col_det_vocal, lwd_det_vocal visual characteristics detection events related vocalizations. lty_det_move, col_det_move, lwd_det_move visual characteristics detection events related movements. alpha alpha channel colors. show_tint, show_rint whether time distance intervals displayed. col_tint, col_rint colors time distance intervals. condition conditioning type define availability individual, see bsims_detect. type x axis : time distance. ... graphical arguments.","code":""},{"path":"/reference/plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot methods — plot.bsims_landscape","text":"main plotting functions use theme defined option getOption(\"bsims_theme\"). Overriding default settings allows customization.","code":""},{"path":"/reference/plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot methods — plot.bsims_landscape","text":"plotting functions called side effects silently return input object. col2hex modeled col2rgb returns character vector giving hexadecimal color codes without alpha channel values.","code":""},{"path":"/reference/plot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot methods — plot.bsims_landscape","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot methods — plot.bsims_landscape","text":"","code":"b <- bsims_all(road=1, edge=2, move_rate=1, movement=0.2)$new() o <- getOption(\"bsims_theme\") str(o) #> List of 20 #>  $ col_H        : chr \"darkolivegreen1\" #>  $ col_E        : chr \"burlywood1\" #>  $ col_R        : chr \"lightgrey\" #>  $ col_nest     : chr \"darkgreen\" #>  $ pch_nest     : num 3 #>  $ cex_nest     : num 1 #>  $ col_vocal    : chr \"blue\" #>  $ pch_vocal    : num 21 #>  $ cex_vocal    : num 0.5 #>  $ col_move     : chr \"orange\" #>  $ lty_move     : num 1 #>  $ lwd_move     : num 1 #>  $ col_det_vocal: chr \"black\" #>  $ lty_det_vocal: num 1 #>  $ lwd_det_vocal: num 1 #>  $ col_det_move : chr \"purple\" #>  $ lty_det_move : num 1 #>  $ lwd_det_move : num 1 #>  $ col_tint     : chr \"red\" #>  $ col_rint     : chr \"red\" n <- o n$col_H <- \"gold\" n$col_E <- \"magenta\" n$col_R <- \"black\" op <- par(mfrow=c(1, 2)) plot(b) options(\"bsims_theme\" = n) # apply new theme plot(b)  par(op) options(\"bsims_theme\" = o) # reset old theme  col2hex(c(blu = \"royalblue\", reddish = \"tomato\"), alpha = FALSE) #>       blu   reddish  #> \"#4169E1\" \"#FF6347\"  col2hex(c(blu = \"royalblue\", reddish = \"tomato\"), alpha = TRUE) #>         blu     reddish  #> \"#4169E1FF\" \"#FF6347FF\""},{"path":"/reference/rlnorm2.html","id":null,"dir":"Reference","previous_headings":"","what":"Reparametrized lognormal distribution — rlnorm2","title":"Reparametrized lognormal distribution — rlnorm2","text":"lognormal distribution parametrized mean (ybar) SDlog.","code":""},{"path":"/reference/rlnorm2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reparametrized lognormal distribution — rlnorm2","text":"","code":"rlnorm2(n, mean = exp(0.5), sdlog = 1)"},{"path":"/reference/rlnorm2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reparametrized lognormal distribution — rlnorm2","text":"n number random numbers desired. mean mean. sdlog log scale standard deviation.","code":""},{"path":"/reference/rlnorm2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reparametrized lognormal distribution — rlnorm2","text":"Log scale mean log(mean) - sdlog^2/2.","code":""},{"path":"/reference/rlnorm2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reparametrized lognormal distribution — rlnorm2","text":"Vector random numbers.","code":""},{"path":"/reference/rlnorm2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reparametrized lognormal distribution — rlnorm2","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/rlnorm2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reparametrized lognormal distribution — rlnorm2","text":"","code":"summary(rlnorm2(10^6, 1.3, 0.5)) # mean ~ 1.3 #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #>  0.09961  0.81938  1.14818  1.30126  1.60919 14.82229  exp(log(1.3) - 0.5^2/2) # ~ median #> [1] 1.147246"},{"path":"/reference/rmvn.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate normal distribution — rmvn","title":"Multivariate normal distribution — rmvn","text":"shim mvrnorm return matrix n < 2.","code":""},{"path":"/reference/rmvn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate normal distribution — rmvn","text":"","code":"rmvn(n = 1L, mu, Sigma, ...)"},{"path":"/reference/rmvn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate normal distribution — rmvn","text":"n number random vectors desired (nonnegative integer, can 0). mu mean vector. Sigma variance-covariance matrix. ... arguments passed  mvrnorm.","code":""},{"path":"/reference/rmvn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate normal distribution — rmvn","text":"matrix n rows length(mu) columns.","code":""},{"path":"/reference/rmvn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Multivariate normal distribution — rmvn","text":"Peter Solymos","code":""},{"path":[]},{"path":"/reference/rmvn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate normal distribution — rmvn","text":"","code":"rmvn(0, c(a=0, b=0), diag(1, 2, 2)) #>      a b rmvn(1, c(a=0, b=0), diag(1, 2, 2)) #>               a         b #> [1,] 0.07367677 0.5774976 rmvn(2, c(a=0, b=0), diag(1, 2, 2)) #>              a          b #> [1,] 2.7525866  0.6731855 #> [2,] 0.3517842 -0.9324766  sapply(0:10, function(n) dim(rmvn(n, c(a=0, b=0), diag(1, 2, 2)))) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] #> [1,]    0    1    2    3    4    5    6    7    8     9    10 #> [2,]    2    2    2    2    2    2    2    2    2     2     2"},{"path":"/reference/run_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Shiny apps — run_app","title":"Run Shiny apps — run_app","text":"Run Shiny apps included bSims package.","code":""},{"path":"/reference/run_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Shiny apps — run_app","text":"","code":"run_app(app = c(\"bsimsH\", \"bsimsHER\", \"distfunH\", \"distfunHER\"))"},{"path":"/reference/run_app.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Shiny apps — run_app","text":"app character, app run.","code":""},{"path":"/reference/run_app.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Shiny apps — run_app","text":"\"bsimsH\": explore simulation settings single stratum. \"bsimsHER\": explore simulation settings multiple strata. \"distfunH\": explore distance functions single stratum. \"distfunHER\": explore distance functions multiple strata segmented sound attenuation (see dist_fun2).","code":""},{"path":[]},{"path":"/news/index.html","id":"version-03-1-2022-11-11","dir":"Changelog","previous_headings":"","what":"Version 0.3-1, 2022-11-11","title":"Version 0.3-1, 2022-11-11","text":"Better print method bsims_all (#18).","code":""},{"path":"/news/index.html","id":"version-03-0-2021-10-05","dir":"Changelog","previous_headings":"","what":"Version 0.3-0, 2021-10-05","title":"Version 0.3-0, 2021-10-05","text":"CRAN release: 2021-10-07 Updated vignettes. Addressed deldir issues vignette due deldir CRAN update. Specified deldir version (>= 1.0-2) DESCRIPTION.","code":""},{"path":"/news/index.html","id":"version-02-4-2021-04-09","dir":"Changelog","previous_headings":"","what":"Version 0.2-4, 2021-04-09","title":"Version 0.2-4, 2021-04-09","text":"Added singing direction related anisotropy detection transcription.","code":""},{"path":"/news/index.html","id":"version-02-3-2021-03-15","dir":"Changelog","previous_headings":"","what":"Version 0.2-3, 2021-03-15","title":"Version 0.2-3, 2021-03-15","text":"Shiny app fixes allow vocalization movement related tau values.","code":""},{"path":"/news/index.html","id":"version-02-2-2021-01-17","dir":"Changelog","previous_headings":"","what":"Version 0.2-2, 2021-01-17","title":"Version 0.2-2, 2021-01-17","text":"Added sensitivity argument bsims_detect. Revised vignettes.","code":""},{"path":"/news/index.html","id":"version-02-1-2019-12-16-cran","dir":"Changelog","previous_headings":"","what":"Version 0.2-1, 2019-12-16 (CRAN)","title":"Version 0.2-1, 2019-12-16 (CRAN)","text":"CRAN release: 2019-12-20 Replaced \\dontrun{} \\donttest{} Rd files. Added references Rd files DESCRIPTION DOI.","code":""},{"path":"/news/index.html","id":"version-02-0-2019-12-09","dir":"Changelog","previous_headings":"","what":"Version 0.2-0, 2019-12-09","title":"Version 0.2-0, 2019-12-09","text":"Added tutorial vignette (#10). Added run_app run Shiny apps. Added estimate method fit simple models estimate density.","code":""},{"path":"/news/index.html","id":"version-01-3-2019-09-18","dir":"Changelog","previous_headings":"","what":"Version 0.1-3, 2019-09-18","title":"Version 0.1-3, 2019-09-18","text":"Incorporated feedback (GitHub issues #1-8).","code":""},{"path":"/news/index.html","id":"version-01-2-2019-07-02","dir":"Changelog","previous_headings":"","what":"Version 0.1-2, 2019-07-02","title":"Version 0.1-2, 2019-07-02","text":"Shiny apps added /inst/shiny folder.","code":""},{"path":"/news/index.html","id":"version-01-1-2019-06-24","dir":"Changelog","previous_headings":"","what":"Version 0.1-1, 2019-06-24","title":"Version 0.1-1, 2019-06-24","text":"simulation fixed edge=0.","code":""},{"path":"/news/index.html","id":"version-01-0-2019-06-21","dir":"Changelog","previous_headings":"","what":"Version 0.1-0, 2019-06-21","title":"Version 0.1-0, 2019-06-21","text":"Initial functionality stable.","code":""},{"path":"/news/index.html","id":"version-00-1-2019-05-15","dir":"Changelog","previous_headings":"","what":"Version 0.0-1, 2019-05-15","title":"Version 0.0-1, 2019-05-15","text":"Initial functionality added.","code":""}]
